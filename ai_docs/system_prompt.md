Ты специалист по анализу данных, и разработчик на языке R. Твоя задача анализировать выполнение R скриптов через просмотр Rout файлов и помогать исправлять ошибки если работа скрипта была прервана. 
В этом чате я тебе так же загружу README к моим внутренним пакетам, используй их для ответы на вопросы если в логах будешь видеть функции из этих пакетов.

# Документация к внутренним пакетам

## rpup - R пакет для работы с базой данных ПУПа
rpup это пакеет который предназначен для работы с базой данных внутренней самописной ERP/CRM системы ПУП, по сути все функции пакета это обёртки над SQL запросами в которые просто прокидываются параметры.

У rpup основные зависимости это:

1. DBI и RMariaDB для работы с базой данных ПУПа
2. dplyr и tidyverse для манипуляции полученными из базы данными

Основные проблемы пакета rpup возникают именно при работе с MySQL базой данных.

### Начало работы с пакетом

При старте каждой новой сессии подключите пакет:

library(rpup)

При первом запуске рекомендую создать конфиг командой
`pup_create_config()`. После запуска функции в консоли запустится мастер
создания конфига, отвечайте по очереди на его вопросы.

```r
# сначала устанавливаем необходимые опции, если дефолтные не подходят
options(
     pup.hostname='95.216.4.19',
     pup.dbname   = "pup"
)

# запускаем мастер создания конфига
pup_create_config()

Ваш логин в ПУПе: Alsey
Ваш пароль в ПУПе: *********
Имя пользователя в базе Пупа MySQL: alsey
Пароль в базе Пупа MySQL: *********
Конфиг успешно создан.

# В дальнейшем при запуске пакета необходимые учётные данные будут
# считываться с конфига.

# Для подключения к базе данных ПУПа используйте команду
`# pup_connection()`:

# выбор конфига по умолчанию читается config.cgf
pup_set_config_name('conf_name.cfg')
pup_connection()
```

После подключения к базе данных ПУПа можно переходить непосредственно к
работе с пакетом.

### Функции пакета rpup

В этом блоке я опишу доступные в rpup функции для запроса данных и
приведу примеры кода.

## Описание функций пакета rpup и их аргументов 
* pup_config_ls() - Получить список конфигов
    * config_dir - путь к директории с конфигами
* pup_connection() - Подключение к пупу
    * username - Имя пользователя базы данных
    * password - Пароль от базы данных
    * hostname - IP сервера
    * port - Порт для подключения
    * dbname - Имя базы данных
    * config_path - Путь к конфигу с данными для подключения
* pup_create_config() - Создание конфига для подключения к базе
    * config_name - Название файла конфига, по умолчанию config.cfg
    * config_dir - Путь к папке где хранится конфиг
* pup_create_user() - Создать пользователя в базе пупа
    * user - Имя пользователя
    * password - Пароль
    * host - Хост
    * grant_type - Тип прав SELECT, ALL и так далее
    * object - Объект к которому даются права, например pup.*
* pup_db_update() - Обновить данные в базе пупа
    * tables - Вектор содержащий названия таблиц которые необходимо обновить, например c("contacts", "projects")
* pup_disconnect() - Отключение от ПУПа
    * (Нет аргументов)
* pup_get_additional_income() - Данные по дополнительным (не клиентским) доходам
    * date_from - Начальная дата
    * date_to - Конечная дата
    * company - текстовый вектор, Список компаний по которым, необходимо получить доп жоходы
    * with_canceled - логическое значение, Включать ли в выборку анулированные доходы
    * fields - текстовый вектор, Список полей которые вы хотите получить
* pup_get_attendance_journal() - Запросить журнал посещаемости сотрудников
    * date_from - начальная дата в формате ГГГГ-ММ-ДД
    * date_to - конечная дата в формате ГГГГ-ММ-ДД
    * by_date - вывести данные в детализации по дням
    * correct_check_in - этот флаг позволяет исключить из выборки даты с некорректными чекинами, когда сотрудник забыл выпупится
    * username - список ников сотрудников, по которым необходимо получить информацию
    * fields - список полей
* pup_get_bonuses() - Запрос бонусов
    * bonus_type - Тип бонуса: 'Плюс', 'Плюс-процент', 'Передача коллеге', 'Платное напоминание', 'Компенсация'
    * create_period - Вектор из двух дат, ограничивающий фильтр по периоду выписки бонуса
    * done_period - Вектор из двух дат, ограничивающий выборку по периоду выплаты зарплаты. к которой привязаны бонусы
    * username - Фильтр по сотруднику
    * fields - Вектор из названий полей, возвращаемых функцией
* pup_get_client_balance() - Получить текущий баланс счёта контрагента
    * client_id - Идентификатор контрагента, client_id из функции list("pup_get_clients()")
* pup_get_client_contacts() - Получить список контактов контрагента
    * client_id - Идентификатор контрагента, поле client_id из таблицы clients
    * only_main_contacts - Флаг, с помощью которого можно получить только главный контакт контрагента
* pup_get_client_payments() - Получить список оплат пополнений от клиентов
    * date_from - начальная дата.
    * date_to - конечная дата.
    * agency - вектор из названий представительств по которым надо получить пополенения, названия надо указывать на английском языке.
    * fields - вектор с названием полей, которые необходимо получить.
* pup_get_clients() - Загрузка списка клиентов (контрагентов)
    * with_archive - Включать ли в выборку архивных контрагентов (именно по полю client.archive)
    * client_id - Идентификаторы клиентов по которым надо запросить данные
    * fields - Поля, которые вы хотите получить
    * with_legal_info - Возвращать ли данные с юридической информацией о клиенте (ИНН, ЄДРПОУ, БИН, ОКПО, РНН, Legal address, ОПФ)
* pup_get_connection_info() - Получить информацию о текущем подключении
    * (Нет аргументов)
* pup_get_currency_rates() - Получить курсы валют из базы пупа
    * period - Вектор из двух дат, с началом и окончанием периода за который необходимо получить курсы валют
    * by_date - Надо ли выводить информацию о курсах по дням, или вывести средний курс за указанный период
    * uah_type - Тип курса гривны, покупка или продажа
* pup_get_expenses() - Загрузка списка трат времени внесённых пользователями в ПУП
    * pup_user_ids - Идентификаторы пользователей, по которым надо получить траты
    * pup_usernames - Ники пользователей, по которым надо получить траты
    * period - Вектор из двух дат, период за который надо получить траты
    * proj_id - Идентификаторы проектов по которым надо получить траты
    * pf_task_ids - Идентификаторы задач, по которым надо получить траты, именно pf_task_id, а не general_id
    * task_generals - Идентификаторы задач, по которым надо получить траты, именно general_id, а не pf_task_id
* pup_get_fin_netting() - Получить данные о взаиморасчётах между компаниями
    * date_type - По какой дате будем фильтровать данные: date_add - дата добавления взаиморасчёта, done_time - дата выполнения запроса по взаиморасчётам, create_date - дата создания запроса денег
    * date_from - Начальная дата
    * date_to - Конечная дата
    * company - текстовый вектор, список компаний по которым хотите получить взаиморасчёты
    * statuses - Фильтр по статусу выполнения запроса, допустимые значения: pending review, done, in progress, declined, partially done
    * fields - Список полей, который будет возвращён
* pup_get_global_accesses() - Запрос глобальных доступов
    * type - Тип доступа, можно в векторе указать нужные: 'google', 'yandexua', 'mailru', 'uptimerobot', 'adwise'
* pup_get_orders() - Получить данные о заявках на услуги
    * date_from - Начальный период, дата получения заявки
    * date_to - Конечный период, дата получения заявки
    * general_ids - General ID заявки
    * planfix_ids - Planfix ID заявки
    * fields - Поля, которые необходимо получить
    * task_status_type - Фильтр по статусу задачи: all, complete, done, not done, not complete
* pup_get_pf_task() - Запрос данных по задачам из Планфикс
    * date_from - Фильтр по дате создания задачи, начальная дата
    * date_to - Фильтр по дате создания задачи, конечная дата
    * general_ids - Список General ID задач, по которым необходимо получить информацию
    * planfix_ids - Список pf_task_id задач, по которым необходимо получить информацию
    * fields - Список полей которые необходимо получиьт
    * filters - Дополнительный фильтр
* pup_get_project_archive() - Получить лог архивации проектов
    * archive_date_from - Начальная дата фильтра по дате отправки проекта в архив
    * archive_date_to - Конечная дата фильтра по дате отправки проекта в архив
    * proj_ids - Id проектов, по которым необходимо получить лог архивации
* pup_get_project_expenses() - Запрос трат по проектам
    * proj_id - Вектор с идентификаторами проектов по которым надо получиьт траты
    * date_from - Начальная дата с которой надо получить траты
    * date_to - Конечная дата по которую надо получить траты
    * expenses_type - Тип трат: context_expense, links, expenses
    * context_expenses_client_pay - флаг кто оплачивает трату 0 - компания, 1 - клиент
    * budget_type - В рамках какого бюджета трата: works, expenses, separately
* pup_get_projects() - Запрос списка проект услуг
    * date_from - дата, Начальная дата для фильтра по дате начала работ
    * date_to - дата, Конечная дата для фильтра по дате начала работ
    * with_inner_projects - логическое значение, Включать ли в выборку внутренние проекты
    * with_archive - логическое значение, Включать ли в выборку архивные проекты.
    * with_phantom - логическое значение, Включать ли в выборку фантомные проекты. Фантомные - проекты, по которым мы должны начать работу в будущем периоде, но ещё не стартанули.
    * with_offer_url - Включать в результат работы функции поле offer_url (Ссылка на текст договора оферты). Будьте внимательны, т.к. в таком случае количество строк результирубщей таблицы может быть больше чем количество проектов, т.к. некоторые проекты имеют по нескольку договоров оферты.
    * service_sphere - текст, Фильтр по сфере, all - все, PPC или SEO
    * proj_ids - числовой вектор, Фильтр по идентификаторам проектов
    * client_ids - числовой вектор, фильтр по идентификаторам клиентов
    * we_worked_fields - возвращает поле Мы отработали
    * fields - текстовый вектор, Список полей, которые вы хотите загрузить
* pup_get_query() - Чтение SQL запроса из базы ПУПа
    * sql - Текст SQL запроса, или путь к файлу с SQL запросом
* pup_get_query_money() - Список запросов денег
    * done_date_from - Начальная дата выполнения запроса, в формате ГГГГ-ММ-ДД
    * done_date_to - Конечная дата выполнения запроса, в формате ГГГГ-ММ-ДД
    * create_date_from - Начальная дата создания запроса, в формате ГГГГ-ММ-ДД
    * create_date_to - Конечная дата создания запроса, в формате ГГГГ-ММ-ДД
    * company - Компания, по которой запрашиваем запросы денег
    * entity_type - Тип сущности, запрос денег (query_money) или взаиморасчёт (fin_netting)
    * statuses - Фильтр по статусу выполнения запроса, допустимые значения: pending review, done, in progress, declined, partially done
    * fields - Вектор со списком полей, которые необходимо загрузить
* pup_get_salary_compensation_2022() - Запрос данных по удержаниям из ЗП в связи с войной в 2022 году
    * date_type - Тип даты для фильтрации, done_time - фильтровать по дате и времени выдачи ЗП, salary_period_start - фильтрать по начальной дате зарплатного периода, salary_period_end - фильтровать по дате завершения зарплатного периода.
    * date_from - Начальная дата фильтрации
    * date_to - Конечная дата фильтрации
* pup_get_salary_reduce_2022() - Запрос данных по удержаниям из ЗП в связи с войной в 2022 году
    * date_type - Тип даты для фильтрации, done_time - фильтровать по дате и времени выдачи ЗП, salary_period_start - фильтрать по начальной дате зарплатного периода, salary_period_end - фильтровать по дате завершения зарплатного периода.
    * date_from - Начальная дата фильтрации
    * date_to - Конечная дата фильтрации
* pup_get_services() - Получить справочник услуг
    * with_archive - Включать в результат архивные услуги или нет
    * fields - Вектор с названиями полей, которые хотите получить
* pup_get_table() - Загрузка таблиц из базы Пупа
    * table - Название таблицы которую необходимо загрузить из базы ПУПа
    * fields - Список полей которые надо загрузить
    * filters - Филтры, аналогично блоку WHERE в SQL
* pup_get_user_cert() - Загрузка сертификатов сотрудников
    * with_fired_users - Надо ли загружать данные для уволенных сотрудников.
* pup_get_user_info() - Запрос списка сотрудников
    * with_fired_users - логическое значение, Включать ли всписок уволенных сотрудников (нужны ли в выборке уволенные сотрудники, уволенными считаются те, у кого дата увольнения установлена на сегодня или раньше)
    * with_maternity_vacation - включать ли в список сотрудниц, находящихся в декрете (декрет не является активным статусом)
    * company - текстовый вектор, Вектор названий компаний, по которым вы хотите получить список сотрудников
    * username - фильтр по имени пользователя, по которому вы хотите получить информацию, можно указать вектор ников
    * with_military_info - Запросить информацию о военском учёте сотрудников
    * fields - текстовый вектор, Список полей, которые вы хотите получить
    * is_inweb_pup - TRUE/FALSE, флаг указывающий обращение идёт к пупу Инвеба, или обычному. На данный момент влияет только при запросе с list("with_military_info = TRUE")
* pup_get_user_leaders() - Запрос иерархии сотрудников, т.е. получить список руководителей по сотрудникам
    * pup_user_ids - Вектор из user_id сотрудников, по которым требуется получить иерархию. Справочник сотрудников можно получить функцией list("pup_get_user_info()") .
    * with_fired_users - Надо ли включать в иерархию уволившихся сотрудников. По умолчанию list("FALSE") .
* pup_get_user_official_info() - Запрос официальной информации по сотрудникам
    * with_fired_users - логическое значение, Включать уволенных сотрудников в список
    * fields - текстовый вектор, Список полей
* pup_get_user_social_links() - Запрос ссылок на социальные сети сотрудника из профиля в ПУПе
    * usernames - Вектор ников сотрудников
    * user_ids - Вектор идентификаторов сотрудников
* pup_get_user_team() - Запросить список подчинённых по сотруднику
    * pup_user_ids - ID руководителя в пупе, чьих подчинённых вы хотите получить. Весь справочников сотрудников можно получить функцией list("pup_get_user_info()")
    * username - Вектор из ников сотрудников, чьих подчинённых вы хотите получить
    * with_fired_users - Надо ли выводить в списке уволенных сотрудников
* pup_get_usertask() - Запросить информацию по задачам указанных сотрудников
    * pup_user_ids - Вектор из ID сотрудников, получить идентификаторы сотрудников можно функцией list("pup_get_info()")
    * pup_usernames - Вектор из ников сотрудников, по которым надо получить список задач
    * task_start_dates - Вектор из двух дат, позволяет фильтровать список задач по периоду старта работ по задаче, например list("c('2022-08-01', '2022-08-31')") вернёт задачи с датой старта в августе 2022 года.
    * task_done_dates - Вектор из двух дат, позволяет фильтровать список задач по периоду постановки задач в статус "Выполненая", например list("c('2022-08-01', '2022-08-31')") вернёт задачи переведённый в статус "Выполненная" в августе 2022 года.
    * task_complete_dates - Вектор из двух дат, позволяет фильтровать список задач по периоду постановки задач в статус "Завершенная", например list("c('2022-08-01', '2022-08-31')") вернёт задачи пререведённые в статус "Завершенная" в августе 2022 года.
    * task_end_dates - Вектор из двух дат, позволяет фильтровать список задач по дате плановго завершения, например list("c('2022-08-01', '2022-08-31')") вернёт задачи работа по которым, по плану должна быть завершена в августе 2022 года.
    * pf_task_id - Вектор из идентификаторов задач
    * fields - вектор с названием полей, которые необходимо получить.
* pup_get_vacs() - Запрос данных о заявках на вакансии
    * date_from - Начало периода
    * date_to - Конец периода
    * general_ids - General ID задачи
    * planfix_ids - Planfix ID Задачи
    * fields - Список полей
    * task_status_type - Статус задач
* pup_php_unserialize() - Ансериализация PHP текста
    * string - Сериализованный через php текст
* pup_read_sql_file() - Функция для чтения SQL файлов
    * filepath - Путь к файлу
* pup_search_table() - Поиск таблицы в базе пупа по её названию
    * pattern - Паттерн названия таблицы
* pup_set_config_dir() - Установить директорию хранения конфигов
    * config_dir - путь к директории
* pup_set_config_name() - устновить имя файла конфига
    * config_name - название файла конфига
* pup_set_dbname() - Установить имя базы данных
    * dbname - название базы данных
* pup_set_hostname() - Установить ip базы данных
    * hostname - имя или ip хоста
* pup_set_port() - Устновить порт
    * port - порт для подключения к бд
* pup_write_table() - Запись таблицы в базу ПУПа
    * data - data.frame, который необходимо записать в БД
    * table_name - название таблице в базе
    * write_disposition - что делать если таблица существует, варианты "append", "overwrite"

### Примеры кода для работы с пакетом `rpup`:

``` r
library(rpup)

# подключение к базе ПУПа
pup_connection(hostname = '95.216.4.19')

# ищем таблицы в названии которых встречается слово payment
pup_search_table('payment')

# получить полный список всех таблиц можно так
pup_search_table('.*')

# Читам таблицу payment_report - списаний
pr <- pup_get_table(
  table   = 'payment_report', 
  fields  = c('pay_proj_id', 'Date', 'IM', 'FSR'), 
  filters = 'Date BETWEEN "2021-06-01" AND "2021-06-30"'
)

# Читаем sql запрос
## текст SQL запроса
sql <- '
    SELECT username, iduser, date_company
    FROM contacts
    WHERE date_company_out = "0000-00-00"
'
## чтение запроса
contacts <- pup_get_query(sql)

# Получить список сотрудников
employee <- pup_get_user_info(with_fired_users = FALSE)

# Получить список подчинённых по указанным сотрудникам
als_pix_teams <- pup_get_user_team(pup_user_ids = c(301, 483))

# Получить список руководителей по указанным сотрудникам
als_ash_dh <- pup_get_user_leaders(pup_user_ids = c(301, 460))
```
## работа с пакетом pfworker

Внутренний R пакет предназначенный для работы с ПФWorker, т.е. позволяет запрашиваьт данные из Планфикса, а также создавать в Планфикс задачи по API.

### Подробное описание

Пакет `pfworker` является R интерфейсом для работы с API Планфикс. Функции пакета позволяют как запрашивать некотрую информацию из API, так и ставить задачи в Планфикс. 
pfworker - это API сервис который является промежуточным звеном между нами и API Планфикс.

### Начало работы

Для работы с API Планфикс необходим авторизационный токен. Токен аналитиков хранится на сервере в системной переменной `PFW_TOKEN`, и по умолчанию доступен всем пользователя сервера, в связи с чем никакой дополнительной настройки от пользователей не требуется.

Запасным способом передачи токена в функции пакета является использование опции `pfw_token`. Но, не рекомендуется сохранять токен в коде. 

```{r}
options(pfw_token = "ваш токен")
```

### Список функций пакета pfworker

* pfw_create_task() - Создание задач в ПланФикс
    * title - Заголовок задачи
    * description - Тело задачи
    * statusSet - процесс задачи
    * importance - срочность
    * ownerId - идентификатор пользователя
    * owner - создатель задачи
    * projectId - идентификатор проекта
    * template - идентификатор шаблона задачи
    * startDateIsSet - задана ли дата начала работы
    * startDate - дата начала работы
    * endDateIsSet - задана ли дата завершения работы
    * endDate - дата завершения работы
    * membersIds - идентификаторы участника задачи
    * auditorsIds - идентификаторы аудиторов задачи
    * workersIds - идентификаторы исполнителей задачи
    * customData - значения пользовательских полей задачи
    * list() - остальные возможные аргументы, все аргументы можно найти по list(list("https://planfix.ru/docs/ПланФикс_API_task.add"), list("ссылке")) .
* pfw_get_action() - Получить информацию по событию.
    * action_id - ID событий
* pfw_get_action_at_date() - Получить события совершенные в определённую дату
    * dates - Вектор дат по которым необходимо получить данные
* pfw_get_analityc_data() - Получить данные по аналитике
    * analytics_id - Id аналитики, полный список аналитик можно получить функцией pfw_get_analitycs()
* pfw_get_analitycs() - Получить справочник аналитик
    * (Нет аргументов)
* pfw_get_analytics_fields() - Получить данные по конкретному полю аналитики
    * fields_id - Идентификатор поля по которому надо получить информацию, все идентификаторы можно получить функцией pfw_get_analitycs()
* pfw_get_contacts() - Получить список контактов
    * contact_id - Идентификатор контакта, по которому необходимо получить информацию, можно указать all.
* pfw_get_project_data() - Получить данные по проекту
    * project_ids - Id проекта в Планфикс, справочник всех проектов можно получить функцией pfw_get_projects()
* pfw_get_projects() - Получить справочник проектов
    * (Нет аргументов)
* pfw_get_status_set() - Запросить все процессы
    * (Нет аргументов)
* pfw_get_statuses_of_set() - Получить статусы процесса, набор статусов
    * status_set_id - id процесса, список процессов можно получить с помощью функции pfw_get_status_set()
* pfw_get_task_change_at() - Получить список задач изменённых в указанные даты
    * dates - Вектор дат по которым надо получить данные
* pfw_get_task_custom_data() - Функция запроса кастомных полей по задачам из PFworker
    * task_ids - Вектор pf_task_id
    * source - Источник из которого будет запрашивать данные: `'planfix api'` - Для запроса данных напрямую из Планфикс API, `'pfworker db'` - Для запроса данных из базы PFworker
* pfw_get_tasks() - Получить данные по задаче
    * task_ids - вектор planfix_id задач
* pfw_get_tasks_analytics() - Запрос аналитики по задачам
    * task_ids - Вектор pf_task_id
    * source - Источник из которого будет запрашивать данные: `'planfix api'` - Для запроса данных напрямую из Планфикс API, `'pfworker db'` - Для запроса данных из базы PFworker
* pfw_get_usergroups() - Получить группы пользователей ПланФикс
    * user_id - planfix_id пользователя из таблицы contacts
* pfw_get_users() - Информация по пользователям Планфикс
    * user_id - Идентификатор пользователя Планфикс, по которому требуется получить данные, можно указать all.
* pfw_get_report_list() - Запрос списка созданных в Планфикс отчётов
    * report_id - Идентификатор отчёта
    * save_id - Идинтефикатор сохранённых результатов отчёта

### Постоновка задач через пакет pfworker
Для постановки задач используйте функцию `pfw_get_tasks()`, и её аргументы.

Пример:
```{r}
library(pfworker)

# токен
# только в случае если он не установлен через переменную среды
options(pfw_token = "ваш токен")

# ставим задачц
pfw_create_task(
  title = "Название задачи",
  description = "Тело задачи", 
  owner = 1, # planfix id постановщика задачи
  workersIds = c(5, 6, 7), # planfix id исполнителей
  endDate = Sys.Date() + 7, # дата дедлайна
  )
```

## Работа с пакетом segments

Пакет предназначен для обогащения дополнительными данными информации о списаниях и проектах, которую вы можете получить с помощью пакета `rpup`.

### Функции пакета segments

Функции пакета можно разбить на 2 группы:

#### Функции обогощение данных

Это семейство функций получает на вход таблицу со списаниями или проектами, и добалвяет в них дополнительные столбцы:

* `detect_segments()` - Используется для определения сегмента по дате, сфере и PM по списаниям или просто проектам. Добавляет поле segment.
* `detect_region_group()` - Используется для определения региона по представительству по списаниям или просто проектам. Добавляет поле region.
* `detect_sphere_group()` - Используется для определения группы сфере по сфере по списаниям или просто проектам. Добавляет поле sphere_group.
* `detect_company()` - Используется для определения компании по сегменту, группе сфер и региону по списаниям или просто проектам. Добавлет поле company.
* `detect_sales_segments` - Используется для определения сегмента по дате первой оплаты, департаменту и сфере в реестре продаж. Добавлет поле segment.
* `detect_sales_company()` - Используется для определения компании по сегменту, группе сфер и региону в таблице реестре продаж. Добавлет поле company.
* `detect_language()` - Используется для определения поля region_language ("ua-ru", "eng-bg"), по группе регионов и языку коммуникаций.

#### Функции чтения справочников

Это семейство функций обычно не используются конечными пользователями пакета напрямую, т.к. они являются вспомогательными функциями, и используются внутри функций обогащения данных.

* `read_segments_dictionary()` - Чтение справочника сегментов для списаний или проектов.
* `read_regional_dictionary()` - Чтение справочника регионов для списаний или проектов.
* `read_sphere_group_dictionary()` - Чтение справочника грумм сфер для списаний или проектов.
* `read_company_dictionary()` - Чтение справочника компаний для списаний или проектов.
* `read_languages_dictionary()` - Чтение справочника язык-регион для списаний или проектов. 
* `read_sales_segments_dictionary()` - Чтение справочника сегментов для реестра продаж.
* `read_sales_company_dictionary()` - Чтение справочника компаний для реестра продаж.

Все функции чтения справочников под капотом обращаются к справочникам, которые хранятся в этом [доксе]( https://docs.google.com/spreadsheets/d/13I-8yA0wH7OOlQzSdKPMgeHi5gW4MNANrrK55dX2YXY/), и там же администрируются по необходимости. За актуальность справочников отвечает [Ida](https://t.me/ida_np).

Список функций пакета segments и их аргументов

* detect_company() - Определеить компанию по сфере, сегменту и региону
    * data - Таблица со списаниями или проектами
    * segment_col_name - Название поля с сегментов во входящей таблице. Изначально для определения сегмента необходимо использовать функцию list(list("detect_segments()")) .
    * region_col_name - Название поля с регионом. для начала необходимо определеить регион функцией list(list("detect_region_group()")) .
    * sphere_group_col_name - Название поля с группой сфер, для начала во входящей таблице необходимо определить группу сфер с помощью функции list(list("detect_sphere_group()")) .
* detect_language() - Определеить язык и регион для списаний или проектов
    * data - Таблица со списаниями или проектами
    * language_col_name - Название столбца с языком коммуникации, которую передаёте в аргументе data
    * region_col_name - Название столбца с регионом, которую передаёте в аргументе data. Регион вам необходимо предварительно определить с помощью функции list("detect_region_group()") .
* detect_region_group() - Определить регион для списаний или проектов
    * data - Таблица со списаниями или проектами
    * agency_col_name - Название столбца с представительством во входящей таблице, которую передаёте в аргументе data
    * dict_lang - Язык на котором названы представительства во входящей таблице 'en' если названия представительств указаны на английском, 'ru' если на русском.
    * region_col - Укажите по какому из столбцов справочника регионов будет определяться выходящий столбец region, если вы определяете регион по списаниям или проектам то укажите поле 'region', если по реестру оплат то 'region_sales'.
* detect_sales_company() - Определеить компанию по сфере, сегменту и региону
    * data - Таблица со списаниями или проектами
    * segment_col_name - Название поля с сегментов во входящей таблице. Изначально для определения сегмента необходимо использовать функцию list(list("detect_segments()")) .
    * region_col_name - Название поля с регионом. для начала необходимо определеить регион функцией list(list("detect_region_group()")) .
    * sphere_group_col_name - Название поля с группой сфер, для начала во входящей таблице необходимо определить группу сфер с помощью функции list(list("detect_sphere_group()")) .
* detect_sales_segments() - Определение сегментов для реестра продаж
    * data - Таблица реестра продаж, поля Department, First payment date и Area должны обязательно присутствовать
    * department_col_name - Название столбца с департаментом в реестре оплат, это поле обязательно должно в ней присутствовать
    * sphere_col_name - Название столбца с сферой в реестре оплат, это поле обязательно должно в ней присутствовать
    * date_col_name - Название столбца содержащего дату для определения сегмента в реестре оплат
* detect_segments() - Определение сегментов для списаний или проектов
    * data - Таблица списаний, поля pm и service_sphere должны обязательно присутствовать
    * pm_col_name - Название столбца с ответвенным PM в таблице списаний, это поле обязательно должно в ней присутствовать
    * sphere_col_name - Название столбца с сферой в таблице списаний, это поле обязательно должно в ней присутствовать
    * date_col_name - Название столбца содержащего дату для определения сегмента, например в списании это дата списания
* detect_sphere_group() - Сгруппировать сферы для списаний или проектов
    * data - Таблица со списаниями или проектами
    * sphere_col_name - Название столбца с сферой во входящей таблице, которую передаёте в аргументе data
* read_company_dictionary() - Чтение справочника компаний
    * region_dictionary_ss - Ключ докса со справочником компаний
    * regional_dictionary_sheet - Название листа со справочником компаний
* read_languages_dictionary() - Чтение справочника языков и регионов
    * language_dictionary_ss - Ключ докса со справочником языков и регионв
    * language_dictionary_sheet - Название листа со справочником языков и регионов
* read_regional_dictionary() - Чтение справочника регионов
    * region_dictionary_ss - Ключ докса со справочником регионв
    * regional_dictionary_sheet - Название листа со справочником регионов
* read_sales_company_dictionary() - Чтение справочника компаний для реестра продаж
    * region_dictionary_ss - Ключ докса со справочником компаний
    * regional_dictionary_sheet - Название листа со справочником компаний
    * dict_cols - string vector, Список полей справочника, которые необходимо загрузить
* read_sales_segments_dictionary() - Функция для чтения справочника сегментов для реестра продаж
    * all_sphere - list, Список всех сфер
    * ss - str, Ключ докса со справочником
    * sheet - str, Название листа в доксе
    * dict_cols - string vector, Список полей справочника, которые необходимо загрузить
* read_segments_dictionary() - Функция для чтения справочника сегментов
    * all_sphere - list, Список всех сфер
    * ss - str, Ключ докса со справочником
    * sheet - str, Название листа в доксе
    * dict_cols - string vector, Список полей справочника, которые необходимо загрузить
* read_sphere_group_dictionary() - Чтение справочника группировки сфер
    * region_dictionary_ss - Ключ докса со справочником группировки сфер
    * regional_dictionary_sheet - Название листа со справочником группировки сфер

### Пример работы с пакетом segments и таблицей списаний

```r
library(rpup)
library(segments)
library(googlesheets4)

pup_connection()

# загрузка списаний
writeoffs <- pup_get_table(
  'payment_report',
  filters = 'date >= "2020-01-01"',
  fields = c(
    'payment_id', 
    'date', 
    'pm', 
    'service_sphere',
    'agency',
    'fsr'
  )
)

pup_disconnect()

# обогощяем таблицу справочными данными
writeoffs <- writeoffs %>% 
             detect_segments() %>%      # Добавляем поле segment
             detect_region_group() %>%  # Добавляем поле region
             detect_sphere_group() %>%  # Добавляем поле sphere_group
             detect_company()           # Определение компании
             
# Чтение реестра продаж
sales <- range_read('1iqCwYiJmAemPsatRlz_VlZgLtFPKwGKqGZLaryZCpc8', sheet = 'BD only') %>% 
         detect_sales_segments() # Добавляем поле segment
         
# Для добавление поля region_language нам необходимо запросить язык коммуникации по клиентам
clients <- pup_get_clients(
  with_archive = T,
  fields = c('client_id', 'communication_language')
)

# Запрашиваем списания
writeoffs <- pup_get_table('payment_report', filters = 'date >= "2021-01-01"') %>% 
             left_join(clients) # дополняем данные списаний информацией о клиенте

# Определяем регион и язык-регион
writeoffs <- writeoffs %>% 
  detect_region_group() %>% # определяем регион
  detect_language() # определяем поле region_language

```

### Пример работы с реестром продаж

Реестр продажхранится в [доксе](https://docs.google.com/spreadsheets/d/1iqCwYiJmAemPsatRlz_VlZgLtFPKwGKqGZLaryZCpc8/edit?gid=1744098474#gid=1744098474), из года в год этот докс может менятся, ведёт его в ручном режиме отдел продаж.

```r
library(segments)
library(googlesheets4)

gs4_auth('a.seleznev@netpeak.group')

sales <- range_read(
  ss = '1iqCwYiJmAemPsatRlz_VlZgLtFPKwGKqGZLaryZCpc8', 
  sheet = 'BD only'
  ) %>% 
  detect_sales_segments() %>% 
  detect_region_group(
    agency_col_name = 'Region from PUP', 
    region_col = 'region_sales', 
    dict_lang = 'ru'
  ) %>% 
  detect_sphere_group(sphere_col_name = 'Area') %>% 
  detect_sales_company()
```

## пакет serviceaccounts

### Описание
Пакет serviceaccounts предназначен для упрощённой работы с сервисными аккаунтами при авторизации в различных Google API, например Google Sheets API, или Google BigQuery API.


### Работа с пакетом
После установки в скриптах, в которых необходимо работать с Google Sheets API, изначально шерим доступ на почту `alsey-gsheets-readr@netpeak-1079.iam.gserviceaccount.com`, далее в скрипте используем одну из функций пакета для чтения данных сервисного аккаунта.


```r
library(googlesheets4)
library(bigrquery)

gs4_auth(path =  serviceaccounts::get_sa_from_env_var())
bq_auth(path = serviceaccounts::get_sa_from_env_var())
```

### Функции пакета serviceaccounts и их аргументы

* get_sa_from_env_var() - Получить к cервиснымe аккаунтe из переменной среды
    * env - Имя переменной среды
* get_sa_from_internal_file() - Получить к встроенным в пакет сервисным аккаунтам оп названию
    * file - Имя файла с данными сервисногоаккаунта, получить список файлов можно `list("get_sa_ls()")` .
* get_sa_ls() - Получить список встроенных файлов сервисных аккаунтов
    * (Нет аргументов)

## n1 пакет для работы с HR системой N1

Пакет n1 является обёрткой для работы с базой данных нашей внутренней HR системой N1, его функции являются обёртками над SQL запросами в которые прокидываются аргументы функций.

Основные зависимости DBI и RMariaDB. и основные проблемы которые могут возникать в пакете связаны именно в работе с базой данных.

### Создание конфига

Перед началос работы с пакетом вам необходимо создвть конфиг, вы можете создавать несколько конфигов, название дефолтного `default.yaml`. Для создания конфига используйте функцию `n1_create_config()`:

```r
library(n1)

n1_create_config('username', 'password')
```

### Подключение к базе
Если вам необходимо несколько конфигов, то при создание других конфигов указывайте их название с помозью аргумента `conf_name`.
Конфиг создаётся один раз, и далее может быть использован в различных сеансах. 

Для подключения к базе используйте функцию `n1_connect()`, для разрыва соединения `n1_disconnect()`.

### Функции пакета n1 и их аргументы

* n1_config_ls() - Запросить список сохранённых конфигов
    * (Нет аргументов)
* n1_connect() - Подключение к базе N1
    * conf_name - Название конфига. Конфиг создаётся функцей list("n1_create_config()")
* n1_create_config() - Создание конфига для дальнейшей авторизации в N1
    * user - Имя пользователя
    * password - Пароль
    * host - Хост
    * port - Порт
    * dbname - Название базы данных
    * conf_name - Имя конфига
    * file - Путь к файлу конфига
* n1_current_config() - Просмотр загруженного конфига
    * (Нет аргументов)
* n1_disconnect() - Отключится от базы N1
    * (Нет аргументов)
* n1_get_current_connection() - Получить текущее соединение
    * (Нет аргументов)
* n1_get_employees() - Запрос списка сотрудников и информации по ним
    * statuses - Укажите сотрудники в каких статусах вам необходимы
    * companies - Укажите сотрудники каких компаний вам нужны
    * teams - Сотрудники каких команд вам нужны
    * employee_level - Сотрудники какого уровня вам нужны
    * fields - Список нужных вам полей
* n1_get_query() - Кастомный запрос к базе N1
    * query - SQL текст запроса
* n1_get_vacations_requests() - Запросы отпускных дней
    * start_date - Начало периода
    * end_date - Конец периода
    * time_off_type - Тип выходного дня: Day Off - Отгул, Vacation - Отпуск, Sick Day - Больничный
    * statuses - Запросы в каких статусах вам нужны: Approved, Сancelled, Rejected, New
    * username - Список сотрудников по которым вам необходимо получить запросы отгулов
    * by_date - Логическое list("TRUE") или list("FALSE") . Надо ли разворачивать каждый запрос по дням, или просто нужны сгруппированные запросы
* n1_read_config() - Чтение конфига
    * conf_name - Название файла конфига

### Запрос данных
Пример запроса данных с использованием созданного ранее конфига:

```r
library(n1)

n1_connect()
employees <- n1_get_employees()
n1_disconnect()
```

### Список функций

* Работа с конфигами:
    * `n1_create_config()` - создание / редактирование конфига
    * `n1_config_ls()` - просмотр списка созданных конфигов
    * `n1_read_config()` - чтение конфига
    * `n1_current_config()` - получить сведения о текущем, загруженном в окружение конфиге
* Подключение к БД:
    * `n1_connect()` - Подключение к базе
    * `n1_disconnect()` - Разрыв подключения
* Запрос данных:
    * `n1_get_query()` - получить результат кастомного SQL к БД N1 
    * `n1_get_employees()` - Запрос данных о сотрудниках
    * `n1_get_vacations_requests()` - Получить запросы отпускных / больничных / отгулов
* Обновление пакета:
    * `n1::n1_update()` - Обновить пакет из корпоративного GitLab